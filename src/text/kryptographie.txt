[Image: Alice + Bob]
Hello! I am Alice and this is my friend Bob. Perhaps you have already met us while learning about the secret communication. Both of us are experts in it, thanks to the jealous Eve, who constantly spies us. But since we use cryptography, it's not that easy anymore!
The cryptography (altgr. Kryptós = "hidden, secret" and gráphein = "write") is the science of encryption of information. It contains a variety of encryption, which you can find in the margin column. However, they all have something in common: All encryption has the task of granting the secrecy, authentication, integrity or binding of a message. These are all very complicated words! Bob and I have all experienced it ourselves. In the following scenarios I am the "sender" and send Bob, the "receiver" a message to arrange a meeting point.
[Ü]: Scenario 1 - Secrecy
[Fig-secrecy]
In this scenario, I would like to send (Alice) a message to my friend Bob to arrange where we meet. Eve, however, burrows as usual in his mailbox! If she reads this message, she could show up at the meeting point and play a trick on us. I therefore turn to secrecy so that the message for Eva is impossible or as difficult to understand.
[Ü]: Scenario 2 - Authentication
[Fig-authentication]
I'll send Bob a message again. Eva has come up with something new. She wants to send Bob a message, but she's going to be Alice. Now Bob has two letters and does not know what to do! So I need proof of identity or authentication for my letters, so Bob can check what message actually comes from me.
[Ü]: Scenario 3 - Integrity
[Fig Integrity]
Again I send (Alice) a message to my friend. Eva grasps the message in the mailbox, and changes it. This is how Bob and I never get together! The message must therefore retain its integrity - which means inviolable.
[Ü]: Scenario 4 - Liability
[Fig-liability]
Similar to scenario 2, Eva sends a message to my name, but did not quite think about it. Bob recognizes the fraud and asks her to apologize, but she denies having sent this message. Bob needs a means to make messages binding and unambiguously identify the sender.
These are the objectives of encryption. But what is such an encryption at all and how do you fix it?
Perhaps you remember the terms that Bob introduced in the chapter on cryptology. Here you can see the table again:
[Table of cryptography]
Encryption E was described as a method. In fact, they are also called "cryptographic procedures". Such an algorithm includes an algorithm and a protocol.
A cryptographic algorithm is actually nothing but a mathematical function, that is, a calculation rule. We can imagine a bit like a machine. In this machine you can insert a character string, the plaintext M, and get the secret back. Mathematically one writes this as follows:
E (M) = C
Here, E is the machine, that is, the cryptographic method, which is in the parenthesis of the "input" and as a result of the "output". The decryption also works in the same way:
D (C) = M
In order for the deciphering to revert to the plaintext, both functions need an important property: injectivity. This means that two different inputs in E () can not have the same result. Only then:
D (E (M)) = C
If you need explanations for all these mathematical terms, press MATHEMATICS in the margin column.
But what is the difference to a spoken language? Let's imagine the situation.
[diagram]
Alice sends me a message. We symbolise the algorithm with a box, which can be opened and closed by a certain method. The message is in this box. Eva again lurks after the postman and gets the crate. Now she does not know how the box is opened, but she can go to the library exactly as Alice and I and get information. Once she has figured out how our algorithm works, she can read our message undisturbed. And because she knows our algorithm, she can read all our messages in the future. That would be terrible! This is exactly the problem when you use a game language.
The solution? Very simple: our crate needs a key. Eva now knows how to open the box, that is, insert and turn the key. Nevertheless, it can not perform this algorithm because it does not have the key! So the problem is solved and we have an ENCRYPTION.
For encryption, two types can be distinguished. There is Symmetric Encryption. Alice and I have the same key. For asymmetric encryption, we have two different keys. How is that? By clicking the two topics in the margins, you can learn more about them.
Now you do not need much more to the finished encryption. All we need is a protocol so that everything is done in the most thorough and the same way. This includes, for example, how the keys are to be exchanged, or which intermediate players, e.g. Eva or a postman, there is. But this is not complicated at all, because this is simply done, as before, with pictures and diagrams.
